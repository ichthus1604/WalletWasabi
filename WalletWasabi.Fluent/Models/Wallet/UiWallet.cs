using DynamicData;
using NBitcoin;
using System.Collections.Generic;
using System.Reactive.Linq;
using System.Reactive;
using WalletWasabi.Blockchain.TransactionProcessing;
using WalletWasabi.Wallets;
using WalletWasabi.Blockchain.Transactions;
using ReactiveUI;
using System.Linq;
using WalletWasabi.Fluent.ViewModels.Wallets.Labels;
using WalletWasabi.Fluent.Helpers;

namespace WalletWasabi.Fluent.Models;

internal class UiWallet : IUiWallet
{
	private readonly Wallet _wallet;
	private readonly TransactionHistoryBuilder _historyBuilder;

	public UiWallet(Wallet wallet)
	{
		_wallet = wallet;
		_historyBuilder = new TransactionHistoryBuilder(_wallet);

		RelevantTransactionProcessed =
			Observable.FromEventPattern<ProcessedResult?>(_wallet, nameof(_wallet.WalletRelevantTransactionProcessed))
					  .ObserveOn(RxApp.MainThreadScheduler);

		Transactions =
			Observable.Defer(() => BuildSummary().ToObservable())
					  .Concat(RelevantTransactionProcessed.SelectMany(_ => BuildSummary()))
					  .ToObservableChangeSet(x => x.TransactionId);

		UnusedAddresses =
			Observable.Defer(() => _wallet.GetUnusedAddresses().ToObservable())
					  .Concat(RelevantTransactionProcessed.SelectMany(_ => _wallet.GetUnusedAddresses()))
					  .ToObservableChangeSet(x => x.Text);
	}

	public IObservable<EventPattern<ProcessedResult?>> RelevantTransactionProcessed { get; }

	public string Name => throw new NotImplementedException();

	public IObservable<Money> Balance => throw new NotImplementedException();

	public IObservable<IChangeSet<Address, string>> UnusedAddresses { get; }

	public IObservable<IChangeSet<TransactionSummary, uint256>> Transactions { get; }

	public Address CreateReceiveAddress(IEnumerable<string> destinationLabels)
	{
		return _wallet.CreateReceiveAddress(destinationLabels);
	}

	public IEnumerable<(string Label, int Score)> GetMostUsedLabels(Intent intent)
	{
		var labelPool = new Dictionary<string, int>(); // int: score.

		// Make recent and receive labels count more for the current wallet
		var multiplier = 100;
		foreach (var label in _wallet.KeyManager.GetReceiveLabels().Reverse().SelectMany(x => x.Labels))
		{
			var score = (intent == Intent.Receive ? 100 : 1) * multiplier;
			if (!labelPool.TryAdd(label, score))
			{
				labelPool[label] += score;
			}

			if (multiplier > 1)
			{
				multiplier--;
			}
		}

		// Receive addresses should be more dominant.
		foreach (var label in WalletHelpers.GetReceiveAddressLabels().SelectMany(x => x.Labels))
		{
			var score = intent == Intent.Receive ? 100 : 1;
			if (!labelPool.TryAdd(label, score))
			{
				labelPool[label] += score;
			}
		}

		// Change addresses shouldn't be much dominant, but should be present.
		foreach (var label in WalletHelpers.GetChangeAddressLabels().SelectMany(x => x.Labels))
		{
			var score = 1;
			if (!labelPool.TryAdd(label, score))
			{
				labelPool[label] += score;
			}
		}

		multiplier = 100; // Make recent labels count more.
		foreach (var label in WalletHelpers.GetTransactionLabels().SelectMany(x => x.Labels).Reverse())
		{
			var score = (intent == Intent.Send ? 100 : 1) * multiplier;
			if (!labelPool.TryAdd(label, score))
			{
				labelPool[label] += score;
			}

			if (multiplier > 1)
			{
				multiplier--;
			}
		}

		var unwantedLabelSuggestions = new[]
		{
			"test", // Often people use the string "test" as a label. It obviously cannot be a real label, just a test label.
			"zerolink mixed coin", // Obsolated autogenerated label from old WW1 versions.
			"zerolink change", // Obsolated autogenerated label from old WW1 versions.
			"zerolink dequeued change" // Obsolated autogenerated label from old WW1 versions.
		};

		var labels = labelPool
			.Where(x =>
				!unwantedLabelSuggestions.Any(y => y.Equals(x.Key, StringComparison.OrdinalIgnoreCase))
				&& !x.Key.StartsWith("change of (", StringComparison.OrdinalIgnoreCase)); // An obsolated autogenerated label pattern was from old WW1 versions starting with "change of (".

		var mostUsedLabels = labels
			.GroupBy(x => x.Key)
			.Select(x => new
			{
				Label = x.Key,
				Score = x.Sum(y => y.Value)
			})
			.OrderByDescending(x => x.Score)
			.ToList();

		return mostUsedLabels.Select(x => (x.Label, x.Score)).ToList();
	}

	private IEnumerable<TransactionSummary> BuildSummary()
	{
		return _historyBuilder.BuildHistorySummary();
	}
}
